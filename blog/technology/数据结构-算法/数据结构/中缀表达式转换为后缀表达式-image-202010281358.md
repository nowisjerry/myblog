# 中缀表达式转换为后缀表达式

 2012-09-20 21:34:02

在回复中说明不够清晰，在这里说明下，本文第一部分摘自《数据结构和算法分析-C语言描述》一书，只是做了一些概括和总结。

## 一、后缀表达式求值

后缀表达式也叫逆波兰表达式，其求值过程可以用到栈来辅助存储。假定待求值的后缀表达式为：`6  5  2  3  + 8 * + 3  +  *`则其求值过程如下：

1）遍历表达式，遇到的数字首先放入栈中，此时栈如下所示：

![img](image-202010281358/1348144826_6731.png)

2）接着读到“+”，则弹出3和2，执行3+2，计算结果等于5，并将5压入到栈中。

![img](image-202010281358/1348144932_4049.png)

3）读到8，将其直接放入栈中。

![img](image-202010281358/1348144994_1525.png)

4）读到“*”，弹出8和5，执行8*5，并将结果40压入栈中。而后过程类似，读到“+”，将40和5弹出，将40+5的结果45压入栈...以此类推。最后求的值288。

 

 

## 二、中缀表达式转后缀表达式

### 方法一

#### 2.1）规则

中缀表达式`a + b*c + (d * e + f) * g`，其转换成后缀表达式则为`a b c * + d e * f + g * +`。

转换过程需要用到栈，具体过程如下：

1）如果遇到操作数，我们就直接将其输出。

2）如果遇到操作符，则我们将其放入到栈中，遇到左括号时我们也将其放入栈中。

3）如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出直到遇到左括号为止。**注意，左括号只弹出并不输出。**

4）如果遇到任何其他的操作符，如`（“+”， “*”，“（”）`等，**从栈中弹出元素直到遇到发现更低优先级的元素(或者栈为空)为止**。弹出完这些元素后，才将遇到的操作符压入到栈中。**有一点需要注意，只有在遇到" ) "的情况下我们才弹出" ( "，其他情况我们都不会弹出" ( "。**

5）如果我们读到了输入的末尾，则将栈中所有元素依次弹出。

 

#### 2.2）实例

规则很多，还是用实例比较容易说清楚整个过程。以上面的转换为例，输入为`a + b * c + (d * e + f)*g`，处理过程如下：

1）首先读到a，直接输出。

2）读到“+”，将其放入到栈中。

3）读到b，直接输出。

此时栈和输出的情况如下：

![img](image-202010281358/1348146428_8057.png)

 

4）读到“*”，因为栈顶元素"+"优先级比" * " 低，所以将" * "直接压入栈中。

5）读到c，直接输出。

此时栈和输出情况如下：

![img](image-202010281358/1348146721_9861.png)

 

6）读到" + "，因为栈顶元素" * "的优先级比它高，所以弹出" * "并输出， 同理，栈中下一个元素" + "优先级与读到的操作符" + "一样，所以也要弹出并输出。然后再将读到的" + "压入栈中。

此时栈和输出情况如下：

![img](image-202010281358/1348147044_5952.png)

 

7）下一个读到的为"("，它优先级最高，所以直接放入到栈中。

8）读到d，将其直接输出。

此时栈和输出情况如下：

![img](image-202010281358/1348147265_9645.png)

 

9）读到" * "，由于只有遇到" ) "的时候左括号"("才会弹出，所以" * "直接压入栈中。

10）读到e，直接输出。

此时栈和输出情况如下：

![img](image-202010281358/1348147424_4303.png)

 

11）读到" + "，弹出" * "并输出，然后将"+"压入栈中。

12）读到f，直接输出。

此时栈和输出情况：

 ![img](image-202010281358/1348147826_1174.png)

 

13）接下来读到“）”，则直接将栈中元素弹出并输出直到遇到"("为止。这里右括号前只有一个操作符"+"被弹出并输出。

![img](image-202010281358/1348147993_7462.png)

 

14）读到" * "，压入栈中。读到g，直接输出。

![img](image-202010281358/1348148087_4361.png)

 

15）此时输入数据已经读到末尾，栈中还有两个操作符“*”和" + "，直接弹出并输出。

![img](image-202010281358/1348148276_3639.png)

至此整个转换过程完成。程序实现代码后续再补充了。

 

### 方法二

####  2.3）转换的另一种方法

1)先按照运算符的优先级对中缀表达式加括号，变成`( ( a+(b*c) ) + ( ((d*e)+f) *g ) )`

2)将运算符移到括号的后面，变成`((a(bc)*)+(((de)*f)+g)*)+`

3)去掉括号，得到`abc*+de*f+g*+`





https://blog.csdn.net/sgbfblog/article/details/8001651