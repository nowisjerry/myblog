# Java面试必考问题：偏向锁、轻量级锁和重量级锁

原创微说互联网2021-03-06 07:55:00

为了减少获得锁和释放锁带来的性能消耗，Java1.6开始，JDK引入了“偏向锁”和“轻量级锁”。synchronized 加锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级。下面我们看一下这几种锁。

## **1、偏向锁（Biased Locking）**

大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。偏向锁是JDK1.6中引用的优化，它的目的是消除无竞争情况下的同步原语，进一步提高程序的性能。

前文《[Java面试必考问题：对象在内存中是如何布局的？](https://www.toutiao.com/i6934342274692268556/?group_id=6934342274692268556) 》介绍过对象头的Mark word会记录锁状态。当锁对象第一次被线程获取的时候，虚拟机使用CAS操作把获取锁的线程ID记录在对象的Mark Word中，线程此时可以进入同步代码块。持有偏向锁的线程以后每次进入同步代码块，虚拟机都可以不做任何同步操作了。

![Java面试必考问题：偏向锁、轻量级锁和重量级锁](Java面试必考问题：偏向锁、轻量级锁和重量级锁.assets/b20de5481e8a4aaebaf0b0b1ad291f5b)

偏向锁状态下的对象Mark Word

简单说，偏向锁的意思就是如果某个线程获取锁成功，下次就更偏向于该线程获得锁，这就是“一回生，二回熟”了。

![Java面试必考问题：偏向锁、轻量级锁和重量级锁](Java面试必考问题：偏向锁、轻量级锁和重量级锁.assets/277de3302ff94b069e20e0ca323407fc)

偏向锁遇到竞争后会升级为轻量级锁

偏向锁遇到竞争后才被释放。等到全局安全点时，虚拟机先暂停拥有偏向锁的线程，然后判断线程是否还活着，如果线程还活着，则升级为轻量级锁，否则，将锁设置为无锁状态。

## **2、轻量级锁（Lightweight Locking）**

轻量级锁也是在JDK1.6中引入的新型锁机制。它的本意是在没有多线程竞争的情况下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

**轻量级锁的加锁**：线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储**锁记录（Lock Record）**的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。

然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程会获得锁；如果失败，当前线程便使用自旋来等待获取锁。

![Java面试必考问题：偏向锁、轻量级锁和重量级锁](Java面试必考问题：偏向锁、轻量级锁和重量级锁.assets/290a8f3b57a74de69d4e4bf92d1be1f0)

轻量级锁状态下的对象Mark Word

![Java面试必考问题：偏向锁、轻量级锁和重量级锁](Java面试必考问题：偏向锁、轻量级锁和重量级锁.assets/35b9beec9c9647acb2362ee936fdc9c1)

对象Mark Word指向栈帧中的Lock record, 同时Lock record保存对象的引用

**轻量级锁的解锁**：轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

## **3、重量级锁（Heavy Monitors）**

synchronized的重量级锁是通过对象内部的管程，也叫**监视器（Monitor）**来实现的，本身依赖于操作系统的**Mutex Lock（互斥锁）**实现。操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高。如果没有线程同时竞争进入临界区，轻量级锁使用CAS操作避免了使用互斥量的开销。

## 总结

![Java面试必考问题：偏向锁、轻量级锁和重量级锁](Java面试必考问题：偏向锁、轻量级锁和重量级锁.assets/8f1999ffc09b42278a5a8320a5ec2895)

随着竞争加剧，偏向锁升级为轻量级锁，再膨胀为重量级锁

最后，我们做一个总结：

- 锁的升级路线是：从偏向锁升级为轻量级琐，再膨胀为重量级琐。
- 如果JVM没有开启偏向锁，那么 new 出来的对象是普通对象（Mark word记录的是对象hashcode）；如果JVM开启偏向锁，那么new出来的对象就是匿名偏向对象（Mark word记录线程Id=0）。
- 当有2个线程竞争同一个锁资源时，偏向锁升级为轻量级琐，所有线程都会自旋抢占锁资源。
- 轻量级锁（自旋锁）在竞争资源的时候，用CAS的方式修改锁对象的Mark word。
- 升级为重量级锁的条件：JDK1.6以前，当某个线程自旋次数上限达到默认的10次，或者自旋线程数量达到了CPU核数的一半时，轻量级锁升级为重量级锁，线程则进入等待队列。JDK1.6之后提供了自适应自旋，JVM根据每个线程的运行情况来判断是否要升级。

综上，JVM对synchronized的优化，主要是三个场景：

1. 只有一个线程进入临界区，使用偏向锁
2. 多个线程交替进入临界区，使用轻量级锁
3. 多线程同时进入临界区，使用重量级锁









[Java面试必考问题：偏向锁、轻量级锁和重量级锁 (toutiao.com)](https://www.toutiao.com/i6933836815539782151/?tt_from=android_share&timestamp=1615044778&app=news_article&use_new_style=1&req_id=20210306233257010151152032234AF455&share_token=d5207a08-741a-4214-be64-0025725b244d&group_id=6933836815539782151)