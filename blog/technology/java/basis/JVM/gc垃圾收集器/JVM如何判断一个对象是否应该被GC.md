# JVM如何判断一个对象是否应该被GC

> 垃圾回收器机制是由Garbage Collection来实现的。GC是后台的守护进程，它是低优先级进程，但是根据内存的使用情况动态的调整它的优先级，因此，它是内存低到一定程度的时候才会自动运行，所以回收时间不确定。
>  GC处理的数据主要在运行时数据区域的堆中（所有对象化的实例都在这里），当一个对象不再被引用时，就会回收这个引用

## GC搜索算法

###  1，引用计数法(不再使用)

 简单但是速度很慢。
 每个对象创建的时候会分配一个引用计数器，当这个对象被引用的时候计数器的值就会+1。任何时候，当引用计数器值为0的时候就说明这个对象不被使用了，需要被GC回收掉。

优点：算法简单。

缺点：当两个或以上对象相互持有对方的引用，但是这些对象已经没有再用到了，而其计数器都不为0，就不会被GC收集，严重的时候会导致内存泄漏。并且类的引用会伴随着一些算数，效率会有点低

### 2，根搜索法

#### 一，以特定的对象作为基础原始对象

以特定的对象作为基础原始对象（也被称为根），通过递归的方式不断向下搜索，从跟对象到达某个对象的路径被称为引用链。如果一个对象和跟对象之间存在引用链，那么这个对象则是存活状态，不能被回收。反之，如果一个对象与根对象之间不存在引用链，那么这个对象是不可达的，那这个对象就是可回收的垃圾对象。**此种算法是GC目前使用的搜索算法。**

优点：可找到所有垃圾对象，并解决了循环引用的情况。

缺点：需要遍历所有对象，而且递归算法难免会导致效率不高。

#### 二，那么都有那些对象可以被称为特定对象呢？

I，JAVA虚拟机栈中的引用对象(栈帧中的局部变量区,也叫局部变量表)。

II，方法区中的类静态属性引用的对象。

III，方法区中的常量引用的对象。

IV，本地方法栈中JNI(Native方法)引用的对象。

#### 三，是否有必要执行finalize()方法

根算法中不可达对象在回收之前，要进行二次标记，第一次标记的时候会进行筛选，筛选是否有必要执行finalize()方法。有以下两种情况不需要执行finalize方法：

I，当前对象类中没有覆盖finalize方法。

II，finalize在前一次GC时已经调用过一次finalize方法了。

如果这个对象有必要执行，则会放在一个队列中，以一个低优先级的线程执行finalize方法进行二次标记，如果在finalize中，对象与根能够建立引用链，那么该对象不会被回收。

**关于finalize方法**

> java技术允许使用finalize方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize方法以整理[系统资源](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.baidu.com%2Fs%3Fwd%3D%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%26tn%3DSE_PcZhidaonwhc_ngpagmjz%26rsv_dl%3Dgh_pc_zhidao)或者被执行其他清理工作

**在根搜索算法的基础上垃圾收集器算法主要有三种：**

> GC算法(https://www.jianshu.com/p/d93ce2784bbe)



 

作者：名字是乱打的
链接：https://www.jianshu.com/p/5593c87d6747
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

